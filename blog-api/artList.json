{
  "requestId": "b0aa21a4a62bb",
  "data": {
    "offset": 0,
    "limit": 8,
    "list": [
      {
        "_id": "63ca5b1366238fb6081d79ce69fba612",
        "_openid": "41fcc65978324a8db4048993dfc0a9df",
        "classes": "JavaScript 常见问题",
        "content": "\n## CommonJS\n\n在`node.js`中，使用 CommonJS 作为其模块化规范。\n\n根据 CommonJS 模块化规范，一个单独的JS文件就是一个模块，每个模块是一个单独的`作用域`，在模块内部定义的变量，无法在其他模块中所读取。若想要在模块间进行通信，需使用模块的导出与导入语法：\n\n- 模块通过变量`exports`向外暴露`API`，注意，`exports`只能是一个对象，该对象的属性即为向外暴露的`API`。\n- 在另一个模块中，通过全局函数`require`引入其他模块导出的`exports`对象。\n\n## 基本语法\n\n例如，`a.js`文件中导出对象`exports`，其中包含了`name`、`add`属性，分别是文件中定义的常量。\n\n```javascript\nconst name = 'Jack';\n\nconst add = (a, b) => a + b;\n\nmodule.exports = {\n  name,\n  add\n};\n```\n\n在文件`b.js`中，通过全局函数`require`引入该导出的对象`exports`。\n\n```javascript\nconst api = require('./a');\n\nconsole.log(api);\n// { name: 'Jack', add: [Function: add] }\n```\n\n注意，`api`这个可以随意取的。通常，也可以通过**解构赋值**的形式，按需进行导入：\n\n```javascript\nconst { name } = require('./a');\n\nconsole.log(name);\n// Jack\n```\n\n## 多次导入\n\n接上述例子，若在`b.js`文件中，多次导入`a`模块，会怎么样呢？两次导入的是同一个对象吗？\n\n```javascript\nconst api1 = require('./a');\nconst api2 = require('./a');\n\nconsole.log(api1 === api2);\n// true\n```\n\n如上述代码所示，`b.js`中两次引入`a`模块，并判断两个导入的变量是否为相等。结果输出`true`，说明若多次引用，实际上导入的模块是同一个对象。\n\n实际上，在第一次导入中，会执行要导入的文件，并在内存中缓存一个对象，其中`exports`就是要导入的对象。再次导入相同模块时，并不会再执行了，会直接从内存中取这个`exports`对象。\n\n```javascript\n{\n  id: '...', // 模块名\n  exports: { ... }, // 模块输出的接口\n  loaded: true, // 模块的脚本是否执行完毕\n  ...\n}\n```\n\n## 是否支持更改\n\n导入模块，实际上就是执行一遍要导入的模块，然后将其输出的`exports`对象，作为`require`函数的返回值。实际上就是普通的**赋值语句**，若使用`var`、`let`进行声明，当然支持更改。\n\n```javascript\nlet api1 = require('./a');\n\napi1 = {};\n\nconsole.log(api1);\n// {}\n```\n\n## 循环引用\n\n若出现某模块被循环加载，**只输出已经执行的部分**，未执行的不会输出。\n\n若在`a.js`中引入`b.js`，在`b.js`中引入`a.js`，形成循环引用，是否会报错呢？若不报错，运行的结果是怎么样的？\n\n还是以代码举例比较清晰。如下代码所示，`a`模块引入`b`模块，`b`模块引入`a`模块。\n\n```javascript\n// a.js\nconst b = require('./b');\n\nconsole.log('b', b);\n\nconst name = 'Jack';\nconst age = 18;\n\nmodule.exports = {\n  name,\n  age\n};\n```\n\n```javascript\n// b.js\nconst a = require('./a');\n\nconsole.log('a', a);\n\nconst id = '001';\n\nmodule.exports = {\n  id\n};\n```\n\n运行`node a.js`，控制台输出如下：\n\n```powershell\na {}\nb { id: '001' }\n```\n\n没有报错，正常运行。这是因为前面提到的原因：若出现某模块被循环加载，**只输出已经执行的部分**，未执行的不会输出。\n\n简单分析一下：\n\n- 运行`node a.js`。首先进入到`a`模块，`a`模块一开始就导入`b`模块，那么就会先执行一遍`b.js`，然后返回`b.js`导出的`exports`对象给`a`模块中的常量`b`。\n- 执行`b.js`。一开始又导入了`a.js`。但是`a.js`并未执行完毕，只会返回已执行的部分。由于`a.js`导出的是`name`、`age`，此时`a.js`只执行到第`1`行，所以实际上此时导入`a.js`，只会返回空对象，因为`name`、`age`还未执行到。所以`require('./a')`返回空对象，赋值给常量`a`，故打印出**空对象**。\n- 接着继续执行`b.js`，将剩下的代码执行完毕，正常导出了`exports`对象，其中包含了`id`属性。\n- 执行完毕后，又回到了`a.js`的第一行中，`require('./b')`返回`b`导出的`exports`对象，包含了`id`属性。所以，下面能正常打印出`{ id: '001' }`。\n- 接着在`a.js`中，将剩余的代码执行完毕。\n\n## 思考题\n\n有`a.js`、`b.js`、`c.js`三个文件，执行`node a.js`，控制台将会输出什么？\n\n```javascript\n// a.js\nconst b = require('./b');\n\nconsole.log(exports.x);\n\nexports.x = 'x';\n\nrequire('./c');\n```\n\n```javascript\n// b.js\n\nconst a = require('./a');\n\nconsole.log(a);\n\na.x = 'y';\n```\n\n```javascript\n// c.js\nconst a = require('./a');\n\nconsole.log(a.x);\n```\n\n答案：\n\n```powershell\n{}\ny\nx\n```\n\n\n\n***\n\n> 以上为本人学习所得，若有不妥，欢迎批评指出！",
        "date": 1663667336000,
        "post": true,
        "tags": [
          "JavaScript",
          "模块化"
        ],
        "title": "一道代码题看 CommonJS 模块化规范",
        "titleEng": "common-js",
        "url": "https://lzxjack.top/post?title=common-js"
      },
      {
        "_id": "2b13da7f66238f0f081a31f80c82d328",
        "_openid": "41fcc65978324a8db4048993dfc0a9df",
        "classes": "JavaScript 常见问题",
        "content": "## Proxy\n\n### Proxy 是什么\n\n通过调用`new Proxy()`，可以创建一个代理用来代替另一个对象，实现基本操作的拦截和自定义。这个代理与目标对象表面上可以被当作同一个对象来看待。\n\n关于`Proxy`有几个术语：\n\n- `traps`：捕获器，提供**访问属性**的方法。\n- `handler`：处理器，一个定义了一个或多个**捕获器**的对象。\n- `target`：被`Proxy`代理虚拟化的对象。\n\n通过如下方式，即可创建一个`Proxy`：\n\n```javascript\nconst p = new Proxy(target, handler);\n```\n\n两个参数即对应上述的相应术语。\n\n### traps 捕获器\n\n`handler`是一个包含了多个捕获器的对象。所有捕获器都是可选的，若`handler`对象上没有定义捕获器，则`Proxy`就会保留目标对象的默认行为。\n\n下面是常见的捕获器：\n\n|           捕获器           |                         被重写的行为                         |\n| :------------------------: | :----------------------------------------------------------: |\n|           `get`            |                       读取一个属性的值                       |\n|           `set`            |                         写入一个属性                         |\n|           `has`            |                          `in`运算符                          |\n|      `deleteProperty`      |                        `delete`运算符                        |\n|      `getPrototypeOf`      |                  `Object.getPrototypeOf()`                   |\n|      `setPrototypeOf`      |                  `Object.setPrototypeOf()`                   |\n|       `isExtensible`       |                   `Object.isExtensible()`                    |\n|    `preventExtensions`     |                 `Object.preventExtensions()`                 |\n| `getOwnPropertyDescriptor` |             `Object.getOwnPropertyDescriptor()`              |\n|      `defineProperty`      |                  `Object.defineProperty()`                   |\n|         `ownKeys`          | `Object.keys`、`Object.getOwnPropertyNames()`与`Object.getOwnPropertySymbols()` |\n|          `apply`           |                         调用一个函数                         |\n|        `construct`         |                         `new`操作符                          |\n\n### 简单使用\n\n以下代码将所有应用到`Proxy`的操作，转发到`obj`对象上。\n\n```javascript\nconst obj = {};\nconst p = new Proxy(obj, {});\n\np.a = 37;\n\nconsole.log(obj.a); // 37\n```\n\n## Reflect\n\n### Reflect 是什么\n\n`Reflect`是一个内置对象，但不是一个构造函数，不能通过`new`操作符来进行实例化。\n\n`Reflect`提供了拦截 JavaScript 操作的方法，这些方法与`Proxy`中`handler`上的捕获器相同。\n\n比如`Reflect.set()`是`set`捕获器函数对应的反射方法，同时也是`set`操作的默认行为。`Reflect.set()`与`set`方法的函数参数相同，可以在捕获器函数中方便地调用。\n\n### 简单使用\n\n如下所示，使用`Reflect.has`检验`obj`对象上是否存在`name`、`say`属性。\n\n```javascript\nconst obj = {\n  name: 'Jack',\n  age: 18\n};\n\nReflect.has(obj, 'name'); // true\nReflect.has(obj, 'say'); // false\n```\n\n## 拦截对象默认行为举例\n\n### 使用 set 验证属性值\n\n如下代码所示，代理了对象`obj`，当设置新属性或者更改属性时，被`set`捕获器拦截。为了防止影响`obj`已有的属性，`trapTarget.hasOwnProperty(key)`加以判断。若传入的参数不是数字时，排除错误。否则通过`Reflect.set`执行其默认行为。\n\n```javascript\nconst obj = {\n  name: 'Jack'\n};\nconst proxy = new Proxy(obj, {\n  set(trapTarget, key, value, receiver) {\n    if (!trapTarget.hasOwnProperty(key)) {\n      if (isNaN(value)) {\n        throw new TypeError('Property must be a number.');\n      }\n    }\n    return Reflect.set(trapTarget, key, value, receiver);\n  }\n});\n\nproxy.age = 18;\nconsole.log(proxy.age); // 18\nconsole.log(obj.age); // 18\n\n// 已有的属性不受影响\nproxy.name = 'Tom';\nconsole.log(proxy.name); // Tom\nconsole.log(obj.name); // Tom\n\n// 抛出错误，定义新属性时，值必须是数字\nproxy.other = 'other';\n```\n\n### 防止访问对象不存在的属性\n\n我们知道，在 JavaScript 中，访问一个对象上不存在的属性时，并不会报错，而是会返回`undefined`。\n\n```javascript\nconst obj = {};\nconsole.log(obj.name); // undefined\n```\n\n这可能引发严重的问题，使用`Proxy`拦截，可以避免此问题。\n\n如下代码所示，拦截空对象`obj`的访问行为，当访问`obj`的属性时，判断访问的`key`是否存在与对象上，若不存在，抛出错误。存在则使用`Reflect.get`执行`get`的默认行为。\n\n```javascript\nconst obj = {};\n\nconst p = new Proxy(obj, {\n  get(trapTarget, key, receiver) {\n    if (!(key in receiver)) {\n      throw new TypeError(`Property ${key} doesn't exist.`);\n    }\n    return Reflect.get(trapTarget, key, receiver);\n  }\n});\n\nobj.name = 'Jack';\n// 访问存在的属性\nconsole.log(p.name); // Jack\n\n// 访问不存在的属性，报错\nconsole.log(p.age); // TypeError: Property age doesn't exist.\n```\n\n### 防止对象属性被删除\n\n如下代码所示，拦截对象的`deleteProperty`操作，当删除对象的属性时，被拦截。若将要删除的属性键名为`id`，则抛出错误，阻止删除。若不为`id`，则执行`Reflect.deleteProperty`的默认操作，删除属性。\n\n```javascript\nconst obj = {\n  id: '123',\n  name: 'Jack'\n};\n\nconst p = new Proxy(obj, {\n  deleteProperty(trapTarget, key) {\n    if (key === 'id') {\n      throw new TypeError(`property ${key} can't be deleted.`);\n    } else {\n      return Reflect.deleteProperty(trapTarget, key);\n    }\n  }\n});\n\ndelete p.name;\nconsole.log(p); // { id: '123' }\n\ndelete p.id;\nconsole.log(p); // TypeError: property id can't be deleted.\n```\n\n\n\n***\n\n> 参考：\n>\n> - <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy\" target=\"_blank\">Proxy - MDN</a>\n> - <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Reflect\" target=\"_blank\">Reflect - MDN</a>",
        "date": 1650274947000,
        "post": true,
        "tags": [
          "JavaScript"
        ],
        "title": "ES6：Proxy与Reflect学习笔记",
        "titleEng": "proxy-reflect",
        "url": "https://lzxjack.top/post?title=proxy-reflect"
      },
      {
        "_id": "d4107ab16253d33a06664d9a7137c70f",
        "_openid": "dbee9976b3c14448a06f2006a4795cf2",
        "classes": "前端基础",
        "content": "使用Web Worker可以在后台线程中运行 JavaScript，线程可以执行任务而不会干扰用户界面。\n\n## 使用规则\n\n- `worker`是使用`Worker()`构造出的实例对象，在后台线程中运行一个命名的 JavaScript 脚本。\n- `worker`实例对象可以通过将信息发送到创建它的 JavaScript 代码。\n- `worker`运行在另一个全局上下文中，而非`window`对象。\n- `worker`中不能直接操作 DOM 节点，也不能使用`window`对象的默认方法和属性。\n- `worker`和主线程之间，通过`postMessage()`方法发送各自的数据，使用`onmessage`事件处理函数来响应数据，数据在`message`事件的`data`属性中。\n- `worker`和主线程之间传递的数据是**另外复制**的数据。\n- 主线程可以使用实例对象上的`terminate()`方法立刻终止该`worker`。\n- `worker`线程内部可以使用`close()`关闭自身。\n- `worker`的一个优势在于能够执行处理器密集型的运算而不会阻塞 UI 线程。\n\n## 应用举例\n\n如下代码所示，在主线程中首先进行了兼容性检验，创建了一个由`worker.js`执行的`Worker`。通过`myWorker.postMessage()`发送消息。通过`myWorker.onmessage`响应`Worker`返回的消息。\n\n```javascript\nconst a = 1;\nconst b = 2;\n\nif (window.Worker) {\n  const myWorker = new Worker('./worker.js');\n  myWorker.postMessage({ a, b });\n\n  myWorker.onmessage = e => {\n    console.log('收到worker的信息...');\n    console.log(e.data);\n  };\n}\n```\n\n在`Worker`中，通过`onmessage`响应主线程发送的消息，经过一些处理后，通过`postMessage`返回消息到主线程。\n\n```javascript\n// worker.js\nonmessage = e => {\n  console.log('收到主线程的信息...');\n  const { a, b } = e.data;\n  const sum = a + b;\n  postMessage(sum);\n};\n```\n\n从这里我们可以看到，主线程中，`onmessage`和`postMessage()`必须挂在`worker`对象上。而在`worker`内部，不必这样做，因为`worker`有自己的作用域。\n\n如下代码所示，在`worker`的`onmessage`中打印`this`：\n\n```javascript\nonmessage = e => {\n  console.log(this);\n};\n```\n\n![image-20220411142557425](https://img.lzxjack.top:99/202204111425460.png)\n\n## 终止 worker\n\n在上述代码中，若在主线程中调用`myWorker.terminate()`，则不会收到任何消息，因为`worker`线程刚创建完毕就被终止。\n\n```javascript\nconst a = 1;\nconst b = 2;\n\nif (window.Worker) {\n  const myWorker = new Worker('./worker.js');\n  myWorker.postMessage({ a, b });\n  // 终止myWorker\n  myWorker.terminate();\n\n  myWorker.onmessage = e => {\n    console.log('收到worker的信息...');\n    console.log(e.data);\n  };\n}\n```\n\n同样，在`worker`线程中调用`close()`，主线程也不会有任何响应，因为线程刚启动就被关闭。\n\n```javascript\nclose();\n\nonmessage = e => {\n  console.log('收到主线程的信息...');\n  const { a, b } = e.data;\n  const sum = a + b;\n  postMessage(sum);\n};\n```\n\n## 共享 worker\n\n主线程：\n\n```javascript\nconst a = 1;\nconst b = 2;\n\nif (window.Worker) {\n  const myWorker = new SharedWorker('./worker.js');\n  myWorker.port.postMessage({ a, b });\n\n  myWorker.port.onmessage = e => {\n    console.log('收到worker的信息...');\n    console.log(e.data);\n  };\n}\n```\n\n`worker`线程：\n\n```javascript\nonconnect = e => {\n  const port = e.ports[0];\n\n  port.onmessage = e => {\n    const { a, b } = e.data;\n    const sum = a + b;\n    port.postMessage(sum);\n  };\n};\n```\n\n\n\n***\n\n> 参考：\n>\n> - <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Using_web_workers\" target=\"_blank\">Using Web Workers</a>",
        "date": 1649660525000,
        "post": true,
        "tags": [
          "JavaScript",
          "HTML"
        ],
        "title": "Web Workers：在后台线程执行指定脚本",
        "titleEng": "web-worker",
        "url": "https://lzxjack.top/post?title=web-worker"
      },
      {
        "_id": "5ca5d2676623904a081c11575be057bc",
        "_openid": "41fcc65978324a8db4048993dfc0a9df",
        "classes": "React 学习笔记",
        "content": "最近学习了状态管理库 redux 的源码，简单记录一下学习笔记。\n\n## redux 简介\n\n`redux`是 JavaScript 的状态管理库，提供可预测的状态管理。\n\n`redux`有几个核心概念：\n\n- `store`：唯一存放状态的容器\n- `state`：状态\n- `action`：状态更新的动作\n- `reducer`：`action`对应的更新状态的动作函数\n- `dispatch`：通过`action`找到对应的`reducer`，更新`state`\n\n`redux`的使用有三大原则：\n\n- 单一数据源\n\n  整个应用的`state`存储在一个状态树中，整个状态树只存在于唯一的`store`里。\n\n- `state`只读\n\n  状态是只读的，不要直接修改`state`。唯一改变`state`的方法就是调用`dispatch`触发`action`。直接修改`state`的话，并不会通知所有订阅者。\n\n- 纯函数执行修改\n\n  `reducer`是纯函数，传入先前的`state`和`action`，返回新的`state`。\n\n## redux 简单使用\n\n如下代码所示，用`redux`简单写了个计数的 demo，仅用到了`createStore`这个方法。\n\n```javascript\nimport { createStore } from 'redux';\n\n// 初始状态\nconst initialState = 0;\n// 创建reducer\nconst reducer = (preState = initialState, action) => {\n  const { type } = action;\n  switch (type) {\n    case 'ADD':\n      return preState + 1;\n    case 'SUB':\n      return preState - 1;\n    default:\n      return preState;\n  }\n};\n\n// 创建store\nconst store = createStore(reducer);\n\n// 订阅，当state改变，打印state\nstore.subscribe(() => console.log(store.getState()));\n\n// 生成action的函数\nconst add = () => ({ type: 'ADD' });\nconst sub = () => ({ type: 'SUB' });\n\nstore.dispatch(add()); // 1\nstore.dispatch(add()); // 2\nstore.dispatch(add()); // 3\nstore.dispatch(add()); // 4\n\nstore.dispatch(sub()); // 3\nstore.dispatch(sub()); // 2\n```\n\n通过这个 demo，可以大致了解`redux`的工作流程：\n\n1. 首先要创建`reducer`函数，它是一个纯函数，接收之前的状态`preState`和`action`，根据`action`作一些处理之后，返回新的`state`。\n2. 使用`createStore`方法创建`store`，接收创建好的`reducer`。其实还可以传入其他参数，后面阅读源码会看到。\n3. `store.subscribe`订阅消息，参数是函数。只有订阅了，在`dispatch`时，才会通知每个监听者。\n4. 定义好不同的`action`，这里定义了两个生成`action`的函数，需要用时，调用这个函数即可。\n5. 最后就是调用`store.dispatch`，根据`action`更新`state`，通知监听者。\n\n## redux 源码笔记\n\n整个`redux`源码的结构如下。\n\n![image-20220406202758343](https://img-blog.csdnimg.cn/img_convert/ddf302263cfac6ea451855a697b83d55.png#pic_center)\n\n`utils`文件夹主要是一些轻量工具函数，比较简单。`index.js`是入口文件，暴露了供开发者使用的方法。其他文件则是相应方法的实现。\n\n下面根据不同文件，整理了自己对其的理解和笔记。\n\n### utils\n\n（1）`actionTypes.js`\n\n这些是`redux`的私有`action`，在代码中不要直接引用这些`action`。\n\n```javascript\n// 随机生成长度为6的字符串，并用.连接\nconst randomString = () => Math.random().toString(36).substring(7).split('').join('.');\n\nconst ActionTypes = {\n  INIT: `@@redux/INIT${randomString()}`,\n  REPLACE: `@@redux/REPLACE${randomString()}`,\n  PROBE_UNKNOWN_ACTION: () => `@@redux/PROBE_UNKNOWN_ACTION${randomString()}`\n};\n\nexport default ActionTypes;\n```\n\n`randomString`使用了`Number.prototype.toString()`，覆盖了`Object`上的`toString()`方法。转换基数为`36`，10 个数字和 26 个字母，表示随机生成随机字符串，包含数字和字母。截取 6 位，用`.`连接。\n\n最后向外暴露了 3 个`action`：`INIT`、`REPLACE`、`PROBE_UNKNOWN_ACTION`。\n\n（2）`formatProdErrorMessage.js`\n\n此文件用来格式化**生产**环境的`error`。不要直接引用此模块。\n\n```javascript\nfunction formatProdErrorMessage(code) {\n  return (\n    `Minified Redux error #${code}; visit https://redux.js.org/Errors?code=${code} for the full message or ` +\n    'use the non-minified dev environment for full errors. '\n  );\n}\n\nexport default formatProdErrorMessage;\n```\n\n（3）`isPlainObject.js`\n\n该方法用来判断一个对象是否是简单对象。\n\n简单对象满足`obj.__proto__ === Object.prototype`。`new Object`和**字面量**创建出的对象，是简单对象。\n\n换句话说，此方法判断的是一个对象是否是`Object`的实例对象。\n\n```javascript\nexport default function isPlainObject(obj) {\n  // 因为typeof null显示为'object'，所以单独讨论\n  if (typeof obj !== 'object' || obj === null) return false;\n\n  let proto = obj;\n  // 沿着__proto__向上遍历原型链\n  while (Object.getPrototypeOf(proto) !== null) {\n    proto = Object.getPrototypeOf(proto);\n  }\n\n  // 最后判断原始对象的__proto__是否等于原型链的最上端\n  return Object.getPrototypeOf(obj) === proto;\n}\n```\n\n（4）`kindOf.js`\n\n该方法是一个判断数据类型的函数，比较简单。值得学习之处是，`typeof`、`constructor`、`instanceof`都可以在一定条件下判断数据类型。\n\n```javascript\nfunction miniKindOf(val) {\n  if (val === void 0) return 'undefined';\n  if (val === null) return 'null';\n\n  // 以下数据类型不用处理\n  const type = typeof val;\n  switch (type) {\n    case 'boolean':\n    case 'string':\n    case 'number':\n    case 'symbol':\n    case 'function': {\n      return type;\n    }\n    default:\n      break;\n  }\n\n  // 单独判断数组、日期、错误对象\n  if (Array.isArray(val)) return 'array';\n  if (isDate(val)) return 'date';\n  if (isError(val)) return 'error';\n\n  // 通过val.constructor.name判断以下类型\n  const constructorName = ctorName(val);\n  switch (constructorName) {\n    case 'Symbol':\n    case 'Promise':\n    case 'WeakMap':\n    case 'WeakSet':\n    case 'Map':\n    case 'Set':\n      return constructorName;\n    default:\n      break;\n  }\n\n  // other\n  return type.slice(8, -1).toLowerCase().replace(/\\s/g, '');\n}\n\nfunction ctorName(val) {\n  return typeof val.constructor === 'function' ? val.constructor.name : null;\n}\n\nfunction isError(val) {\n  return (\n    val instanceof Error ||\n    (typeof val.message === 'string' &&\n      val.constructor &&\n      typeof val.constructor.stackTraceLimit === 'number')\n  );\n}\n\nfunction isDate(val) {\n  if (val instanceof Date) return true;\n  return (\n    typeof val.toDateString === 'function' &&\n    typeof val.getDate === 'function' &&\n    typeof val.setDate === 'function'\n  );\n}\n\nexport function kindOf(val) {\n  let typeOfVal = typeof val;\n\n  // 开发环境下，进一步处理\n  if (process.env.NODE_ENV !== 'production') {\n    typeOfVal = miniKindOf(val);\n  }\n\n  return typeOfVal;\n}\n```\n\n（5）`warning.js`\n\n判断了下`console`是否存在，打印错误信息。\n\n```javascript\nexport default function warning(message) {\n  // 检测console是否存在\n  if (typeof console !== 'undefined' && typeof console.error === 'function') {\n    console.error(message);\n  }\n  try {\n    throw new Error(message);\n  } catch (e) {}\n}\n```\n\n### index.js\n\n该文件是`redux`的入口文件，向开发者暴露了几个方法。\n\n- `createStore`：创建`store`\n- `combineReducers`：将多个`reducer`合并成单个`reducer`\n- `bindActionCreators`：将`action`与对应的`dispatch`方法绑定，生成可以直接执行`action`的函数\n- `applyMiddleware`：增强`redux`功能\n- `compose`：组合函数，连接多个函数\n\n```javascript\nfunction isCrushed() {}\n\n// 若开发环境压缩了代码，提示warning\nif (\n  process.env.NODE_ENV !== 'production' &&\n  typeof isCrushed.name === 'string' &&\n  isCrushed.name !== 'isCrushed'\n) {\n  warning(\n    'You are currently using minified code outside of NODE_ENV === \"production\". ' +\n      'This means that you are running a slower development build of Redux. ' +\n      'You can use loose-envify (https://github.com/zertosh/loose-envify) for browserify ' +\n      'or setting mode to production in webpack (https://webpack.js.org/concepts/mode/) ' +\n      'to ensure you have the correct code for your production build.'\n  );\n}\n\nexport {\n  createStore,\n  combineReducers,\n  bindActionCreators,\n  applyMiddleware,\n  compose,\n  // 不要使用自带的action\n  __DO_NOT_USE__ActionTypes\n};\n```\n\n这里定义了一个`isCrushed`的空函数，目的是判断用户是否压缩了代码，因为如果压缩了代码，函数`isCrushed`的函数名就会被替换，不再是`isCrushed`了。若在**开发环境**下压缩了代码，给出`warning`提示。\n\n### createStore.js\n\n此方法是`redux`源码阅读的重点，也是使用`redux`的第一个步骤。\n\n该方法接收三个参数：`reducer`、`preloadedState`、`enhancer`。`reducer`是产生新`state`的函数，`preloadedState`代表初始状态，`enhancer`是增强`redux`用的函数。\n\n向外暴露了一些方法，其中`dispatch`、`subscribe`、`getState`是开发中常用的方法。\n\n```javascript\nexport default function createStore(reducer, preloadedState, enhancer) {\n  // 判断是否传入多个enhancer，确保只传入一个enhancer\n  // 若要使用多个enhancer，可以将其合并为一个函数\n  if (\n    (typeof preloadedState === 'function' && typeof enhancer === 'function') ||\n    (typeof enhancer === 'function' && typeof arguments[3] === 'function')\n  ) {\n    throw new Error(\n      'It looks like you are passing several store enhancers to ' +\n        'createStore(). This is not supported. Instead, compose them ' +\n        'together to a single function. See https://redux.js.org/tutorials/fundamentals/part-4-store#creating-a-store-with-enhancers for an example.'\n    );\n  }\n\n  // 若第二个参数是函数，且没有传入第三个参数\n  // 则第二个参数作为enhancer，preloadedState不传入\n  if (typeof preloadedState === 'function' && typeof enhancer === 'undefined') {\n    enhancer = preloadedState;\n    preloadedState = undefined;\n  }\n\n  // 首先若传入了enhancer，则返回增强后的createStore执行的结果\n  if (typeof enhancer !== 'undefined') {\n    // 确保enhancer是函数\n    if (typeof enhancer !== 'function') {\n      throw new Error(\n        `Expected the enhancer to be a function. Instead, received: '${kindOf(enhancer)}'`\n      );\n    }\n\n    // 返回增强后的createStore执行的结果\n    return enhancer(createStore)(reducer, preloadedState);\n  }\n\n  // 确保reducer是函数，若不是函数，显示其类型\n  if (typeof reducer !== 'function') {\n    throw new Error(\n      `Expected the root reducer to be a function. Instead, received: '${kindOf(\n        reducer\n      )}'`\n    );\n  }\n\n  // 当前的reducer\n  let currentReducer = reducer;\n  // 当前的state\n  let currentState = preloadedState;\n  // 当前订阅者列表\n  let currentListeners = [];\n  let nextListeners = currentListeners;\n  // 锁，保证数据一致性\n  let isDispatching = false;\n\n  // 当nextListeners和currentListeners是同一个引用时，\n  // 将currentListeners的拷贝赋值给nextListeners\n  // 防止当前队列执行的时候，影响到自身\n  function ensureCanMutateNextListeners() {\n    if (nextListeners === currentListeners) {\n      nextListeners = currentListeners.slice();\n    }\n  }\n\n  // 直接返回当前的state\n  // 从这里可以得到若直接修改currentState，并不会通知订阅者\n  function getState() {\n    // 确保没有其他reducer操作\n    if (isDispatching) {\n      throw new Error(\n        'You may not call store.getState() while the reducer is executing. ' +\n          'The reducer has already received the state as an argument. ' +\n          'Pass it down from the top reducer instead of reading it from the store.'\n      );\n    }\n\n    return currentState;\n  }\n\n  // 添加订阅者\n  // 返回取消订阅的函数\n  function subscribe(listener) {\n    // 确保listener是个函数\n    if (typeof listener !== 'function') {\n      throw new Error(\n        `Expected the listener to be a function. Instead, received: '${kindOf(listener)}'`\n      );\n    }\n\n    // 确保数据唯一性\n    if (isDispatching) {\n      throw new Error(\n        'You may not call store.subscribe() while the reducer is executing. ' +\n          'If you would like to be notified after the store has been updated, subscribe from a ' +\n          'component and invoke store.getState() in the callback to access the latest state. ' +\n          'See https://redux.js.org/api/store#subscribelistener for more details.'\n      );\n    }\n\n    // 该订阅者在订阅状态\n    let isSubscribed = true;\n\n    // 若nextListeners和currentListeners为同一个引用\n    // 将currentListeners作一次浅拷贝，给nextListeners\n    ensureCanMutateNextListeners();\n    // 新的订阅者加入订阅者列表中\n    nextListeners.push(listener);\n\n    // 返回取消订阅的函数\n    return function unsubscribe() {\n      // 若已经取消订阅，不继续执行\n      if (!isSubscribed) {\n        return;\n      }\n\n      // 保证数据唯一性\n      if (isDispatching) {\n        throw new Error(\n          'You may not unsubscribe from a store listener while the reducer is executing. ' +\n            'See https://redux.js.org/api/store#subscribelistener for more details.'\n        );\n      }\n\n      // 取消订阅\n      isSubscribed = false;\n\n      ensureCanMutateNextListeners();\n      // 将该订阅者从订阅者列表中删除\n      const index = nextListeners.indexOf(listener);\n      nextListeners.splice(index, 1);\n      currentListeners = null;\n    };\n  }\n\n  // 分派action，这是触发state更新的唯一方法\n  // action仅支持简单对象，若action是Promise、Observable等，需要使用中间件\n  // action表明了做了什么改变，必须有type属性，并且非undefined，一个好的实践为type是字符串常量\n  // 返回dispatch的action，若使用了中间件，可能返回其他\n  function dispatch(action) {\n    // 确保action是简单对象\n    if (!isPlainObject(action)) {\n      throw new Error(\n        `Actions must be plain objects. Instead, the actual type was: '${kindOf(\n          action\n        )}'. You may need to add middleware to your store setup to handle dispatching other values, such as 'redux-thunk' to handle dispatching functions. See https://redux.js.org/tutorials/fundamentals/part-4-store#middleware and https://redux.js.org/tutorials/fundamentals/part-6-async-logic#using-the-redux-thunk-middleware for examples.`\n      );\n    }\n\n    // 确保action.type存在\n    if (typeof action.type === 'undefined') {\n      throw new Error(\n        'Actions may not have an undefined \"type\" property. You may have misspelled an action type string constant.'\n      );\n    }\n\n    // 确保当前没有在执行其他的reducer操作\n    if (isDispatching) {\n      throw new Error('Reducers may not dispatch actions.');\n    }\n\n    try {\n      // 加锁，防止后续的reducer操作\n      isDispatching = true;\n      // 调用当前的reducer，返回新的state，赋值给currentState\n      currentState = currentReducer(currentState, action);\n    } finally {\n      // 无论是否有错误，都会执行的语句\n      // 当前reducer执行完毕后，解锁\n      isDispatching = false;\n    }\n\n    // 通知订阅者\n    // currentListeners = nextListeners是为了下一次执行的时候，会重新生成一个新的拷贝\n    const listeners = (currentListeners = nextListeners);\n    for (let i = 0; i < listeners.length; i++) {\n      // 执行订阅者的函数，不传入参数\n      const listener = listeners[i];\n      // 执行函数\n      listener();\n    }\n\n    // 最后返回当前的action\n    return action;\n  }\n\n  // 替换reducer\n  // 使用场景：\n  // 1. 代码分割，立即加载reducers的时候\n  // 2. 实现redux热加载机制的时候\n  function replaceReducer(nextReducer) {\n    // 确保nextReducer是函数\n    if (typeof nextReducer !== 'function') {\n      throw new Error(\n        `Expected the nextReducer to be a function. Instead, received: '${kindOf(\n          nextReducer\n        )}`\n      );\n    }\n\n    // 替换reducer\n    currentReducer = nextReducer;\n\n    // 触发state更新\n    dispatch({ type: ActionTypes.REPLACE });\n  }\n\n  // 一般用不到\n  function observable() {\n    // ...\n  }\n\n  // 初始化state，否则第一次的currentState为undefined\n  dispatch({ type: ActionTypes.INIT });\n\n  return {\n    dispatch,\n    subscribe,\n    getState,\n    replaceReducer,\n    [$$observable]: observable\n  };\n}\n```\n\n### combineReducers.js\n\n该方法的作用是合并多个`reducers`为单个`reducer`。输入参数是一个拥有多个`reducer`的对象，最后返回一个函数，处理所有的`reducer`。\n\n```javascript\nfunction getUnexpectedStateShapeWarningMessage(\n  inputState,\n  reducers,\n  action,\n  unexpectedKeyCache\n) {\n  const reducerKeys = Object.keys(reducers);\n  const argumentName =\n    action && action.type === ActionTypes.INIT\n      ? 'preloadedState argument passed to createStore'\n      : 'previous state received by the reducer';\n\n  if (reducerKeys.length === 0) {\n    return (\n      'Store does not have a valid reducer. Make sure the argument passed ' +\n      'to combineReducers is an object whose values are reducers.'\n    );\n  }\n\n  if (!isPlainObject(inputState)) {\n    return (\n      `The ${argumentName} has unexpected type of \"${kindOf(\n        inputState\n      )}\". Expected argument to be an object with the following ` +\n      `keys: \"${reducerKeys.join('\", \"')}\"`\n    );\n  }\n\n  // 找出inputState里有的key，但reducers集合里没有的key\n  const unexpectedKeys = Object.keys(inputState).filter(\n    key => !reducers.hasOwnProperty(key) && !unexpectedKeyCache[key]\n  );\n\n  unexpectedKeys.forEach(key => {\n    unexpectedKeyCache[key] = true;\n  });\n\n  // 如果是替换reducer的action，则提前退出，不打印异常\n  if (action && action.type === ActionTypes.REPLACE) return;\n\n  if (unexpectedKeys.length > 0) {\n    return (\n      `Unexpected ${unexpectedKeys.length > 1 ? 'keys' : 'key'} ` +\n      `\"${unexpectedKeys.join('\", \"')}\" found in ${argumentName}. ` +\n      `Expected to find one of the known reducer keys instead: ` +\n      `\"${reducerKeys.join('\", \"')}\". Unexpected keys will be ignored.`\n    );\n  }\n}\n\n// 用于规范reducers\nfunction assertReducerShape(reducers) {\n  Object.keys(reducers).forEach(key => {\n    const reducer = reducers[key];\n    const initialState = reducer(undefined, { type: ActionTypes.INIT });\n\n    // 确保初始值不为undefined\n    if (typeof initialState === 'undefined') {\n      throw new Error(\n        `The slice reducer for key \"${key}\" returned undefined during initialization. ` +\n          `If the state passed to the reducer is undefined, you must ` +\n          `explicitly return the initial state. The initial state may ` +\n          `not be undefined. If you don't want to set a value for this reducer, ` +\n          `you can use null instead of undefined.`\n      );\n    }\n\n    // 确保遇到未知的action，返回初始值，并且不为undefined\n    // 确保没有占用redux的命名空间\n    if (\n      typeof reducer(undefined, {\n        type: ActionTypes.PROBE_UNKNOWN_ACTION()\n      }) === 'undefined'\n    ) {\n      throw new Error(\n        `The slice reducer for key \"${key}\" returned undefined when probed with a random type. ` +\n          `Don't try to handle '${ActionTypes.INIT}' or other actions in \"redux/*\" ` +\n          `namespace. They are considered private. Instead, you must return the ` +\n          `current state for any unknown actions, unless it is undefined, ` +\n          `in which case you must return the initial state, regardless of the ` +\n          `action type. The initial state may not be undefined, but can be null.`\n      );\n    }\n  });\n}\n\n// 合并多个reducer为单个reducer\n// 输入参数reducers是一个对象，值是需要合并的reducer\n// 会调用所有的子reducer，聚合所有结果合并为一个object\n// 返回合并后的单个reducer\nexport default function combineReducers(reducers) {\n  // reducers对象的key数组\n  const reducerKeys = Object.keys(reducers);\n  // 最终要返回的reducer\n  const finalReducers = {};\n\n  // 遍历key数组，浅拷贝reducers\n  for (let i = 0; i < reducerKeys.length; i++) {\n    const key = reducerKeys[i];\n\n    // 若开发环境，且当前reducer函数名不再存在，给出warning\n    if (process.env.NODE_ENV !== 'production') {\n      if (typeof reducers[key] === 'undefined') {\n        warning(`No reducer provided for key \"${key}\"`);\n      }\n    }\n\n    // 当前reducer是函数，添加到finalReducers中\n    if (typeof reducers[key] === 'function') {\n      finalReducers[key] = reducers[key];\n    }\n  }\n  // 获取finalReducers的所有key\n  const finalReducerKeys = Object.keys(finalReducers);\n\n  // 确保不警告多次相同的key\n  let unexpectedKeyCache;\n  if (process.env.NODE_ENV !== 'production') {\n    // 开发环境为{}\n    unexpectedKeyCache = {};\n  }\n\n  let shapeAssertionError;\n  try {\n    // 确保所有reducers遇到未知的action，返回初始值，且不为undefined\n    // 确保没有占用redux命名空间\n    assertReducerShape(finalReducers);\n  } catch (e) {\n    shapeAssertionError = e;\n  }\n\n  // 返回最后的reducer\n  return function combination(state = {}, action) {\n    // 错误信息\n    if (shapeAssertionError) {\n      throw shapeAssertionError;\n    }\n\n    // 生产环境，找出state里面没有对应reducer的key，给出提示\n    if (process.env.NODE_ENV !== 'production') {\n      const warningMessage = getUnexpectedStateShapeWarningMessage(\n        state,\n        finalReducers,\n        action,\n        unexpectedKeyCache\n      );\n      if (warningMessage) {\n        warning(warningMessage);\n      }\n    }\n\n    // 表示state是否已被更改\n    let hasChanged = false;\n    // 改变后的state\n    const nextState = {};\n    for (let i = 0; i < finalReducerKeys.length; i++) {\n      const key = finalReducerKeys[i];\n      const reducer = finalReducers[key];\n      // 当前key的state值\n      const previousStateForKey = state[key];\n      // 执行当前reducer，拿到state\n      const nextStateForKey = reducer(previousStateForKey, action);\n      // 对新的state做undefined检验\n      if (typeof nextStateForKey === 'undefined') {\n        const actionType = action && action.type;\n        throw new Error(\n          `When called with an action of type ${\n            actionType ? `\"${String(actionType)}\"` : '(unknown type)'\n          }, the slice reducer for key \"${key}\" returned undefined. ` +\n            `To ignore an action, you must explicitly return the previous state. ` +\n            `If you want this reducer to hold no value, you can return null instead of undefined.`\n        );\n      }\n      // 新的state放在相应nextState中\n      nextState[key] = nextStateForKey;\n      // 判断新旧state是不是同一个引用，若state发生变化，则肯定已经改变\n      hasChanged = hasChanged || nextStateForKey !== previousStateForKey;\n    }\n    hasChanged = hasChanged || finalReducerKeys.length !== Object.keys(state).length;\n    // 发生变化则返回nextState，否则返回state\n    return hasChanged ? nextState : state;\n  };\n}\n```\n\n### bindActionCreators.js\n\n该方法的作用是将`action`与对应的`dispatch`方法绑定，生成可以直接执行`action`的函数。\n\n输入参数`actionCreators`可以是创建`action`的函数对象，也可以是单个创建`action`的函数。`dispatch`即为`store`提供的`dispatch`函数。\n\n返回一个与原对象类似的对象，只不过这个对象的`value`都是会直接`dispatch`原`action creator`产生的`action`。如果传入一个单独的函数作为`actionCreators`，那么返回的结果也是一个单独的函数。\n\n```javascript\n// actionCreator是产生action的函数，执行之后，会得到一个action\n// 得到的action再传递给dispatch\n// bindActionCreator函数返回一个自动执行dispatch的方法\nfunction bindActionCreator(actionCreator, dispatch) {\n  // 闭包\n  return function () {\n    // 返回结果为dispatch这个actionCreator并传参\n    return dispatch(actionCreator.apply(this, arguments));\n  };\n}\n\n//  actionCreators：创造action的函数对象\nexport default function bindActionCreators(actionCreators, dispatch) {\n  // 如果是一个函数，直接执行bindActionCreator并返回\n  if (typeof actionCreators === 'function') {\n    return bindActionCreator(actionCreators, dispatch);\n  }\n\n  // 错误处理\n  if (typeof actionCreators !== 'object' || actionCreators === null) {\n    throw new Error(\n      `bindActionCreators expected an object or a function, but instead received: '${kindOf(\n        actionCreators\n      )}'. ` +\n        `Did you write \"import ActionCreators from\" instead of \"import * as ActionCreators from\"?`\n    );\n  }\n\n  const boundActionCreators = {};\n  // 遍历每个函数\n  for (const key in actionCreators) {\n    // 拿到每个函数\n    const actionCreator = actionCreators[key];\n    if (typeof actionCreator === 'function') {\n      // 将自动执行dispatch的方法放到boundActionCreators中\n      boundActionCreators[key] = bindActionCreator(actionCreator, dispatch);\n    }\n  }\n  return boundActionCreators;\n}\n```\n\n### compose.js\n\n该方法将多个函数连接起来，上一个函数的返回值作为下一个函数的参数输入。\n\n注意，它的执行顺序为**从右到左**。\n\n```javascript\n// 将多个函数连接起来：上一个函数的返回值作为下一个参数的输入\n// 最终得到最后的返回值\n// 从右向左的顺序执行\nexport default function compose(...funcs) {\n  if (funcs.length === 0) {\n    return arg => arg;\n  }\n\n  if (funcs.length === 1) {\n    return funcs[0];\n  }\n\n  // 利用reduce方法执行每个中间件函数，并将上一个函数的返回作为下一个函数的参数\n  // a:上一次调用回调的返回值，b:当前处理的元素\n  // 所以是从右向左的顺序执行\n  // compose(f, g, h)\n  // (...args) => f(g(h(...args)))\n  return funcs.reduce(\n    (a, b) =>\n      (...args) =>\n        a(b(...args))\n  );\n}\n```\n\n### applyMiddleware.js\n\n该方法用来增强`redux`功能，主要执行过程为，在`dispatch`的时候，按照传入的中间件顺序，依次执行，最后返回一个增强后的`store.dispatch`方法。\n\n这里用到了上面的`compose`方法。\n\n一个注意点，这里首先定义了`dispatch`为一个抛出错误函数，目的是为了防止在中间件构造过程中调用`dispatch`。构造完成后，再将最终的`dispatch`赋值完成。\n\n```javascript\nexport default function applyMiddleware(...middlewares) {\n  // 返回一个参数为createStore的函数\n  return createStore =>\n    (...args) => {\n      // 创建store\n      const store = createStore(...args);\n      // 定义一个dispatch，如果在中间件构造过程中调用，则抛出错误\n      let dispatch = () => {\n        throw new Error(\n          'Dispatching while constructing your middleware is not allowed. ' +\n            'Other middleware would not be applied to this dispatch.'\n        );\n      };\n\n      // 在中间件中要用到的两个方法\n      const middlewareAPI = {\n        getState: store.getState,\n        dispatch: (...args) => dispatch(...args)\n      };\n      // 依次调用middleware，存放在chain数组中\n      const chain = middlewares.map(middleware => middleware(middlewareAPI));\n      // 用compose整合chain数组，并赋值给dispatch\n      dispatch = compose(...chain)(store.dispatch);\n\n      // 返回增强的store\n      return {\n        ...store,\n        dispatch\n      };\n    };\n}\n```\n\n## 手写简易 redux\n\n阅读完了`redux`的源码，来实现一个简易版的`createStore`方法，来实现「redux 简单使用」小节的功能。\n\n实现`createStore`的功能，核心常用的方法就是`subscribe`、`dispatch`、`getState`这三个。\n\n其实核心思路就是定义一个监听者列表，有新订阅时，将其回调函数放入监听者列表。`dispatch`中通过`reducer`更新旧状态，并通知所有订阅者。\n\n```javascript\nfunction createStore(reducer) {\n  // 状态\n  let state;\n  // 监听者列表\n  const listeners = [];\n\n  // 订阅\n  function subscribe(listener) {\n    listeners.push(listener); // 每订阅一个，就为监听器添加一个回调函数\n  }\n\n  // 更新 state\n  function dispatch(action) {\n    // 调用 reducer，更新 state\n    state = reducer(state, action);\n    // 通知所有订阅者\n    listeners.forEach(i => i());\n  }\n\n  // 获取 state\n  function getState() {\n    return state;\n  }\n\n  // 返回 store 对象\n  return {\n    subscribe,\n    dispatch,\n    getState\n  };\n}\n```\n\n\n\n***\n\n> 参考\n>\n> - <a href=\"https://github.com/reduxjs/redux\" target=\"_blank\">redux</a>\n> - <a href=\"https://www.redux.org.cn/\" target=\"_blank\">Redux 中文文档</a>\n> - <a href=\"https://jelly.jd.com/article/61b57c900ef40701ad5d88aa\" target=\"_blank\">用 25 行代码手写一个 Redux</a>\n",
        "date": 1649339475000,
        "post": true,
        "tags": [
          "Redux"
        ],
        "title": "学习 redux 源码笔记：redux 是如何工作的？",
        "titleEng": "redux-source",
        "url": "https://lzxjack.top/post?title=redux-source"
      },
      {
        "_id": "d2fe6f206246bd2303a72b194292e628",
        "_openid": "dbee9976b3c14448a06f2006a4795cf2",
        "classes": "JavaScript 常见问题",
        "content": "## JSON.stringify\n\n### 语法\n\n```javascript\nJSON.stringify(value[, replacer [, space]])\n```\n\n- `value`：将要序列化成 一个 JSON 字符串的值\n- `replacer`：如果该参数是一个函数，则在序列化过程中，被序列化的值的每个属性都会经过该函数的转换和处理；如果该参数是一个数组，则只有包含在这个数组中的属性名才会被序列化到最终的 JSON 字符串中；如果该参数为 null 或者未提供，则对象所有的属性都会被序列化。\n- `space`：指定缩进用的空白字符串，美化输出。\n\n### 举例\n\n如下代码所示，演示了`JSON.stringify`的用法。\n\n当传入第2个参数，且是一个函数时，被序列化的每个属性都会经过函数的转化。函数有两个参数：`key`和`value`，这里对`value`进行了`a`转`A`的操作。\n\n当传入第2个参数，且是一个数组时，只有在这个数组中的属性名才会被返回。这里`a`、`c`、`d`被返回。\n\n当传入第3个参数，这里传入了**两个空格**，起到美化输出的作用。\n\n```javascript\nconst obj = {\n  a: 'a',\n  b: 'b',\n  c: {\n    d: 'd'\n  }\n};\n\n// 简单使用\nconsole.log(JSON.stringify(obj));\n// {\"a\":\"a\",\"b\":\"b\",\"c\":{\"d\":\"d\"}}\n\n// 传入replacer，为函数\nconsole.log(\n  JSON.stringify(obj, (key, value) => {\n    if (value === 'a') {\n      return 'A';\n    }\n    return value;\n  })\n);\n// {\"a\":\"A\",\"b\":\"b\",\"c\":{\"d\":\"d\"}}\n\n// 传入replacer，为数组\nconsole.log(JSON.stringify(obj, ['a', 'c', 'd']));\n// {\"a\":\"a\",\"c\":{\"d\":\"d\"}}\n\n// 传入space，美化输出\nconsole.log(JSON.stringify(obj, null, '  '));\n// {\n//   \"a\": \"a\",\n//   \"b\": \"b\",\n//   \"c\": {\n//     \"d\": \"d\"\n//   }\n// }\n```\n\n### 安全问题\n\n#### 数据丢失\n\n（1）Date对象拷贝后，变成字符串\n\n```javascript\nconst obj = {\n  a: new Date()\n};\n\nconsole.log(JSON.stringify(obj));\n// {\"a\":\"2022-04-01T08:40:48.781Z\"}\n```\n\n（2）正则、Error对象拷贝后，变成空对象\n\n```javascript\nconst obj = {\n  a: /[123]/g,\n  b: new Error('err')\n};\n\nconsole.log(JSON.stringify(obj));\n// {\"a\":{},\"b\":{}}\n```\n\n（3）函数、`undefined`属性、`Symbol`属性拷贝后属性丢失\n\n```javascript\nconst obj = {\n  a: console.log,\n  b: undefined,\n  c: Symbol('123')\n};\n\nconsole.log(JSON.stringify(obj));\n// {}\n```\n\n（4）`NaN`、`Infinity`、`-Infinity`拷贝后变成`null`\n\n```javascript\nconst obj = {\n  a: NaN,\n  b: Infinity,\n  c: -Infinity\n};\n\nconsole.log(JSON.stringify(obj));\n// {\"a\":null,\"b\":null,\"c\":null}\n```\n\n（5）改变对象的原型链\n\n```javascript\nfunction A() {\n  this.a = 'a';\n}\n\nconst a = new A();\nconst b = JSON.parse(JSON.stringify(a));\n\nconsole.log(a.constructor, b.constructor);\n// [Function: A] [Function: Object]\n```\n\n#### 循环引用报错\n\n```javascript\nconst a = {\n  a: 'a'\n};\n\nconst b = {\n  b: 'b'\n};\n\na.next = b;\nb.pre = a;\n\nconsole.log(JSON.parse(JSON.stringify(a)));\n// TypeError: Converting circular structure to JSON\n```\n\n\n\n## JSON.parse\n\n### 语法\n\n```javascript\nJSON.parse(text[, reviver])\n```\n\n- `text`：要被解析成 JavaScript 值的字符串\n- `reviver`：转换器，如果传入该函数，可以用来修改解析生成的原始值，调用时机在`parse`函数返回之前\n\n### 举例\n\n如下代码所示，传入第二个参数，对`value`进行处理，处理完再返回。\n\n```javascript\nconst str = '{\"a\":1,\"b\":2,\"c\":3}';\n\n// 简单使用\nconsole.log(JSON.parse(str));\n// { a: 1, b: 2, c: 3 }\n\n// 传入reviver，处理value\nconsole.log(\n  JSON.parse(str, (key, value) => {\n    if (key === '') return value;\n    return 2 * value;\n  })\n);\n//{ a: 2, b: 4, c: 6 }\n```\n\n### 兼容性问题\n\n支持主流浏览器。\n\n\n\n***\n\n> 参考：\n>\n> - <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify\" target=\"_blank\">MDN-JSON.stringify</a>\n> - <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/JSON/parse\" target=\"_blank\">MDN-JSON.parse</a>",
        "date": 1648803076000,
        "post": true,
        "tags": [
          "JavaScript",
          "JSON"
        ],
        "title": "JavaScript关于JSON字符串的相关操作",
        "titleEng": "json",
        "url": "https://lzxjack.top/post?title=json"
      },
      {
        "_id": "63605076623d4a0301963437303413bd",
        "_openid": "dbee9976b3c14448a06f2006a4795cf2",
        "classes": "杂七杂八",
        "content": "## 问题\n\n最近在重构博客时，遇到了一个问题。在生产模式下，使用的`MiniCssExtractPlugin.loader`代替`style-loader`，但图片、字体等资源文件输出路径设置不正确，webpack 配置如下：\n\n```javascript\nmodule.exports = merge(common, {\n  target: 'browserslist',\n  mode: 'production',\n  devtool: false,\n  output: {\n    path: path.resolve(ROOT_PATH, './build'),\n    publicPath: './',\n    filename: 'js/[name].[contenthash:8].js',\n    chunkFilename: 'js/[name].[contenthash:8].js',\n    // 资源\n    assetModuleFilename: 'assets/[name].[contenthash:8].[ext]'\n  },\n  plugins: [\n    // 生产模式使用了MiniCssExtractPlugin.loader，则需要使用MiniCssExtractPlugin\n    new MiniCssExtractPlugin({\n      filename: 'css/[name].[contenthash:8].css',\n      chunkFilename: 'css/[name].[contenthash:8].chunk.css'\n    })\n  // ...\n  ],\n  \n  // ...\n}\n```\n\n设置了`output.assetModuleFilename`在`assets`目录下，然而线上的路径却为：\n\n![](https://img.lzxjack.top:99/202203251231114.png)\n\n可以看到，线上的图片引入路径多了一个`css`目录，而打包出来的文件结构如下，图片资源确实是在`assets`目录下的：\n\n![](https://img.lzxjack.top:99/202203251232025.png)\n\n引入的路径应该往上跳出一层目录，才能正确地访问到图片。\n\n## 解决\n\n后来找到了解决办法，在 webpack 配置文件中，使用`MiniCssExtractPlugin.loader`时，配置一个`publicPath`，让其向上跳出一层目录：\n\n```javascript\n{ loader: MiniCssExtractPlugin.loader, options: { publicPath: '../' } }\n```\n\n打包后的文件结构没有变化，线上的引入路径变为如下：\n\n![](https://img.lzxjack.top:99/202203251242487.png)\n\n与打包的文件结构相符，正确引入了图片。\n\n## 参考\n\n> <a href=\"https://github.com/webpack-contrib/mini-css-extract-plugin\" target=\"_blank\">mini-css-extract-plugin</a>",
        "date": 1648183717000,
        "post": true,
        "tags": [
          "Webpack"
        ],
        "title": "解决webpack5打包CSS图片路径不正确问题",
        "titleEng": "webpack-img-err",
        "url": "https://lzxjack.top/post?title=webpack-img-err"
      },
      {
        "_id": "54ad1eea622762321504de7e0a67209b",
        "_openid": "dbee9976b3c14448a06f2006a4795cf2",
        "classes": "杂七杂八",
        "content": "## 前言\n\n最近学习了 Webpack 5 之后，想自己搭建个项目练练手，于是就搭建了一个基于 Webpack 5 的 React 的脚手架。\n\n脚手架配置了相关模块，集成了常用功能，便于自己以后 React 新项目的搭建，开箱即用！\n\n仓库地址：<a href=\"https://github.com/lzxjack/my-react\" target=\"_blank\">「Github」</a>\n\n## 模块/功能\n\n- 框架`React`\n- 路由`react-router-dom`\n- `Typescript`\n- 状态管理库`redux`\n- 样式预处理`less`、`sass`\n- 代码检测`eslint`\n- `git commit`前规范检测`commitlint`\n- 时间库`dayjs`\n- UI库`antd`，配置了**样式按需引入**、**自定义主题**\n- `react hooks`库`ahooks`\n\n## 目录结构\n\n项目的整体目录结构如下所示，其中为了测试可用性，添加了一些简单的组件和页面，可自行更改。\n\n```powershell\n│  .babelrc  // Babel配置\n│  .commitlintrc.js  // commitlint配置\n│  .eslintrc.js  // eslint配置\n│  .gitignore  // git忽略文件列表\n│  package.json\n│  README.md\n│  tsconfig.json  // typescript配置\n│  yarn.lock\n│\n├─public  // 全局文件\n│  │  index.html  // 模板\n│  │\n│  └─assets  // 不需要动态导入的资源\n│          index.css\n│          index.jpg\n│          index.js\n│\n├─scripts  // 脚本\n│  │  antd-theme.js  // antd自定义主题配置\n│  │  constant.js  // webpack相关的常量\n│  │  env.js  // 环境变量\n│  │\n│  └─config\n│          webpack.common.js  // 开发环境+生产环境的公共配置\n│          webpack.dev.js  // 开发环境webpack配置\n│          webpack.prod.js  // 生产环境webpack配置\n│\n└─src\n    │  App.scss\n    │  App.tsx\n    │  index.tsx  // 入口文件\n    │\n    ├─components  // 组件\n    │  └─ErrorBoundary  // 错误边界\n    │          index.tsx\n    │\n    ├─pages  // 页面（写了一些页面测试）\n    │  ├─Admin\n    │  │      index.tsx\n    │  │\n    │  └─Home\n    │          index.tsx\n    │\n    ├─redux  // redux相关\n    │  │  actions.ts\n    │  │  constant.ts\n    │  │  interface.ts\n    │  │  store.ts\n    │  │\n    │  └─reducers\n    │          count.ts\n    │          index.ts\n    │\n    └─types  // 模块声明\n            asset.d.ts\n            style.d.ts\n```\n\n## 主要配置文件\n\n### package.json\n\n主要看`scripts`下的内容。还配置了`git husky`，用于在提交`commit`前自动检测`commit`规范性。\n\n```json\n{\n  \"name\": \"my-react\",\n  \"version\": \"1.0.0\",\n  \"main\": \"index.js\",\n  \"license\": \"MIT\",\n  \"scripts\": {\n    \"start\": \"cross-env NODE_ENV=development webpack-dev-server --config ./scripts/config/webpack.dev.js\",\n    \"build\": \"cross-env NODE_ENV=production webpack --config ./scripts/config/webpack.prod.js\"\n  },\n  \"dependencies\": {\n  \t// ...\n  },\n  \"browserslist\": [\n    \">0.2%\",\n    \"not dead\",\n    \"ie >= 9\",\n    \"not op_mini all\"\n  ],\n  \"husky\": {\n    \"hooks\": {\n      \"commit-msg\": \"commitlint --config .commitlintrc.js -e\"\n    }\n  }\n}\n```\n\n### env.js\n\n导出环境变量。\n\n```js\nconst isDevelopment = process.env.NODE_ENV === 'development';\nconst isProduction = process.env.NODE_ENV === 'production';\n\nmodule.exports = {\n  isDevelopment,\n  isProduction,\n};\n```\n\n### constant.js\n\n导出根路径、HOST、POST。\n\n```js\nconst path = require('path');\n\nconst ROOT_PATH = path.resolve(__dirname, '../');\n\nconst SERVER_HOST = 'localhost';\nconst SERVER_PORT = 8080;\n\nmodule.exports = {\n  ROOT_PATH,\n  SERVER_HOST,\n  SERVER_PORT,\n};\n```\n\n### webpack.common.js\n\n```js\nconst path = require('path');\nconst WebpackBar = require('webpackbar');\nconst HtmlWebpackPlugin = require('html-webpack-plugin');\nconst MiniCssExtractPlugin = require('mini-css-extract-plugin');\nconst ForkTsCheckerWebpackPlugin = require('fork-ts-checker-webpack-plugin');\nconst CopyWebpackPlugin = require('copy-webpack-plugin');\nconst { CleanWebpackPlugin } = require('clean-webpack-plugin');\nconst AntdDayjsWebpackPlugin = require('antd-dayjs-webpack-plugin');\n\nconst { ROOT_PATH } = require('../constant');\nconst { isDevelopment, isProduction } = require('../env');\nconst { myAntd } = require('../antd-theme');\n\nconst getCssLoaders = () => {\n  const cssLoaders = [\n    // 开发模式使用style-loader，生产模式MiniCssExtractPlugin.loader\n    isDevelopment ? 'style-loader' : MiniCssExtractPlugin.loader,\n    {\n      loader: 'css-loader',\n      options: {\n        modules: {\n          // 模块化类名，防止重复\n          localIdentName: '[local]--[hash:base64:5]',\n        },\n        sourceMap: isDevelopment,\n      },\n    },\n  ];\n\n  // 加css前缀的loader配置\n  const postcssLoader = {\n    loader: 'postcss-loader',\n    options: {\n      postcssOptions: {\n        plugins: [\n          isProduction && [\n            'postcss-preset-env',\n            {\n              autoprefixer: {\n                grid: true,\n              },\n            },\n          ],\n        ],\n      },\n    },\n  };\n\n  // 生产模式时，才需要加css前缀\n  isProduction && cssLoaders.push(postcssLoader);\n\n  return cssLoaders;\n};\n\nconst getAntdLessLoaders = () => [\n  isDevelopment ? 'style-loader' : MiniCssExtractPlugin.loader,\n  {\n    loader: 'css-loader',\n    options: {\n      sourceMap: isDevelopment,\n    },\n  },\n  {\n    loader: 'less-loader',\n    options: {\n      sourceMap: isDevelopment,\n      lessOptions: {\n        // antd 自定义主题\n        modifyVars: myAntd,\n        javascriptEnabled: true,\n      },\n    },\n  },\n];\n\nmodule.exports = {\n  entry: {\n    index: path.resolve(ROOT_PATH, './src/index'),\n  },\n\n  plugins: [\n    // html模板\n    new HtmlWebpackPlugin({\n      template: path.resolve(ROOT_PATH, './public/index.html'),\n      filename: 'index.html',\n      inject: 'body',\n    }),\n    // 打包显示进度条\n    new WebpackBar(),\n    // webpack打包不会有类型检查，强制ts类型检查\n    new ForkTsCheckerWebpackPlugin({\n      typescript: {\n        configFile: path.resolve(ROOT_PATH, './tsconfig.json'),\n      },\n    }),\n    // 复制不用动态导入的资源\n    new CopyWebpackPlugin({\n      patterns: [\n        {\n          context: 'public',\n          from: 'assets/*',\n          to: path.resolve(ROOT_PATH, './build'),\n          toType: 'dir',\n          globOptions: {\n            dot: true,\n            gitignore: true,\n            ignore: ['**/index.html'], // **表示任意目录下\n          },\n        },\n      ],\n    }),\n    // 自动删除上一次打包的产物\n    new CleanWebpackPlugin(),\n    // 将antd中的moment.js替换为day.js\n    new AntdDayjsWebpackPlugin(),\n  ],\n\n  module: {\n    rules: [\n      {\n        test: /\\.css$/,\n        exclude: /node_modules/,\n        use: getCssLoaders(),\n      },\n      {\n        test: /\\.less$/,\n        exclude: /node_modules/,\n        use: [\n          ...getCssLoaders(),\n          {\n            loader: 'less-loader',\n            options: {\n              sourceMap: isDevelopment,\n            },\n          },\n        ],\n      },\n      {\n        test: /\\.less$/,\n        exclude: /src/,\n        use: getAntdLessLoaders(),\n      },\n      {\n        test: /\\.scss$/,\n        exclude: /node_modules/,\n        use: [\n          ...getCssLoaders(),\n          {\n            loader: 'sass-loader',\n            options: {\n              sourceMap: isDevelopment,\n            },\n          },\n        ],\n      },\n      {\n        test: /\\.(tsx?|js)$/, // ts\\tsx\\js\n        loader: 'babel-loader',\n        options: { cacheDirectory: true }, // 缓存公共文件\n        exclude: /node_modules/,\n      },\n      {\n        test: [/\\.bmp$/, /\\.gif$/, /\\.jpe?g$/, /\\.png$/],\n        // 自动选择导出为单独文件还是url形式\n        type: 'asset',\n        parser: {\n          dataUrlCondition: {\n            maxSize: 4 * 1024,\n          },\n        },\n      },\n      {\n        test: /\\.(eot|svg|ttf|woff|woff2?)$/,\n        // 分割为单独文件，并导出url\n        type: 'asset/resource',\n      },\n    ],\n  },\n\n  // 路径配置别名\n  resolve: {\n    alias: {\n      '@': path.resolve(ROOT_PATH, './src'),\n    },\n    // 若没有写后缀时，依次从数组中查找相应后缀文件是否存在\n    extensions: ['.tsx', '.ts', '.js', '.json'],\n  },\n\n  // 缓存\n  cache: {\n    // 基于文件系统的持久化缓存\n    type: 'filesystem',\n    buildDependencies: {\n      // 当配置文件发生变化时，缓存失效\n      config: [__filename],\n    },\n  },\n};\n```\n\n### webpack.dev.js\n\n```js\nconst path = require('path');\nconst { merge } = require('webpack-merge');\nconst webpack = require('webpack');\n\nconst common = require('./webpack.common');\nconst { ROOT_PATH, SERVER_HOST, SERVER_PORT } = require('../constant');\n\nmodule.exports = merge(common, {\n  target: 'web', // 解决热更新失效\n  mode: 'development',\n  devtool: 'eval-cheap-module-source-map',\n  output: {\n    path: path.resolve(ROOT_PATH, './build'),\n    filename: 'js/[name].js',\n  },\n  devServer: {\n    host: SERVER_HOST,\n    port: SERVER_PORT,\n    compress: true, // gzip压缩\n    open: true, // 自动打开默认浏览器\n    hot: true, // 启用服务热替换配置\n    client: {\n      logging: 'warn', // warn以上的信息，才会打印\n      overlay: true, // 当出现编译错误或警告时，在浏览器中显示全屏覆盖\n    },\n    // 解决路由跳转404问题\n    historyApiFallback: true,\n  },\n  plugins: [\n    // 引入热替换\n    new webpack.HotModuleReplacementPlugin(),\n  ],\n\n  optimization: {\n    minimize: false,\n    minimizer: [],\n    // 代码分割\n    splitChunks: {\n      chunks: 'all',\n      minSize: 0,\n    },\n  },\n});\n```\n\n### webpack.prod.js\n\n```js\nconst path = require('path');\nconst { merge } = require('webpack-merge');\nconst MiniCssExtractPlugin = require('mini-css-extract-plugin');\nconst CssMinimizerPlugin = require('css-minimizer-webpack-plugin');\nconst TerserPlugin = require('terser-webpack-plugin');\nconst BundleAnalyzerPlugin = require('webpack-bundle-analyzer').BundleAnalyzerPlugin;\n\nconst common = require('./webpack.common');\nconst { ROOT_PATH } = require('../constant');\n\nmodule.exports = merge(common, {\n  target: 'browserslist',\n  mode: 'production',\n  devtool: false,\n  output: {\n    path: path.resolve(ROOT_PATH, './build'),\n    filename: 'js/[name].[contenthash:8].js',\n    // 资源\n    assetModuleFilename: 'assets/[name].[contenthash:8].[ext]',\n  },\n  plugins: [\n    // 生产模式使用了MiniCssExtractPlugin.loader，则需要使用MiniCssExtractPlugin\n    new MiniCssExtractPlugin({\n      filename: 'css/[name].[contenthash:8].css',\n      chunkFilename: 'css/[name].[contenthash:8].chunk.css',\n    }),\n    // 查看打包体积大小，启用一个本地服务器\n    new BundleAnalyzerPlugin(),\n  ],\n\n  // 专门存放优化打包的配置\n  optimization: {\n    minimize: true,\n    minimizer: [\n      new CssMinimizerPlugin(),\n      // JS压缩\n      new TerserPlugin({\n        extractComments: false, // 去除所有注释\n        terserOptions: {\n          compress: { pure_funcs: ['console.log'] }, // 去除所有console.log函数\n        },\n      }),\n    ],\n    // 代码分割\n    splitChunks: {\n      chunks: 'all',\n      minSize: 0,\n    },\n  },\n});\n```\n\n## 遇到的问题\n\n### BrowserRouter开发环境404问题\n\n在`webpack.dev.js`添加一项，任何请求都会返回`index.html`文件，解决单页面应用的路由跳转问题。\n\n```js\ndevServer: {\n  // ...\n  historyApiFallback: true,\n}\n```\n\n### 安装 node-sass 失败\n\n先全局安装`node-gyp`：\n\n```powershell\nnpm install -g node-gyp\n```\n\n再到项目根目录下，`yarn`继续安装即可。\n\n### antd 样式按需加载\n\n 安装`babel-plugin-import`，在`.babelrc`文件的`plugins`下，添加一项：\n\n```js\n{\n  \"plugins\": [\n    [\"import\", {\n      \"libraryName\": \"antd\",\n      \"libraryDirectory\": \"es\",\n      \"style\": true  // `style: true` 会加载 less 文件\n    }]\n  ]\n}\n```\n\n正常使用即可，无需再引入样式：\n\n```tsx\nimport React from 'react';\nimport { Button } from 'antd';\nimport { useTitle } from 'ahooks';\n\nconst Admin: React.FC = () => {\n  useTitle('Admin');\n  return <Button type='primary'>按钮</Button>;\n};\n\nexport default Admin;\n```\n\n### css-module 与 antd 样式冲突\n\n当`css-loader`配置了模块化引入时，如下所示：\n\n```js\n// ...\n{\n  loader: 'css-loader',\n  options: {\n    modules: {\n      // 模块化类名，防止重复\n      localIdentName: '[local]--[hash:base64:5]',\n    },\n    sourceMap: isDevelopment,\n  },\n}\n// ...\n```\n\n发现 antd 的样式不显示了。原因是模块化也应用于`node_modules`中的文件，把 antd 中引入的样式也作了模块化，但是引入的组件还是正常的类名，所以显示不出。\n\n解决办法是，将自己写的**业务代码**与**第三方库**的代码配置分开，因为之前 antd 按需加载配置时，配置了`\"style\": true`，加载`less`，所以要单独配置下`less`，只在业务代码中开启`module`：\n\n```js\nmodule.exports = {\n  // ...\n  \n  module: {\n    rules: [\n      {\n        test: /\\.less$/,\n        exclude: /node_modules/, // 排除第三方库代码\n        use: [\n          ...getCssLoaders(), // 正常配置\n          {\n            loader: 'less-loader',\n            options: {\n              sourceMap: isDevelopment,\n            },\n          },\n        ],\n      },\n      {\n        test: /\\.less$/,\n        exclude: /src/, // 排除业务代码\n        use: getAntdLessLoaders(), // 不开启module\n      },\n      // ...\n    ],\n  },\n  \n  // ...\n};\n```\n\n### antd 自定义主题\n\n处理`less`。注意排除业务代码，不开启`module`：\n\n```js\n// antd自定义主题配置\n\nconst myAntd = {\n  'primary-color': '#1DA57A',\n  'link-color': '#1DA57A',\n  'border-radius-base': '8px',\n};\n\nmodule.exports = {\n  myAntd,\n};\n```\n\n```js\nconst { myAntd } = require('../antd-theme');\n\n//...\nconst getAntdLessLoaders = () => [\n  isDevelopment ? 'style-loader' : MiniCssExtractPlugin.loader,\n  {\n    loader: 'css-loader',\n    options: {\n      sourceMap: isDevelopment,\n    },\n  },\n  {\n    loader: 'less-loader',\n    options: {\n      sourceMap: isDevelopment,\n      lessOptions: {\n        // antd 自定义主题\n        modifyVars: myAntd,\n        javascriptEnabled: true,\n      },\n    },\n  },\n];\n//...\n\n{\n  test: /\\.less$/,\n  exclude: /src/,\n  use: getAntdLessLoaders(),\n}\n    \n//...\n```\n\n\n\n***\n\n> 本文记录自己所学，若有不妥，欢迎批评指出~",
        "date": 1646747972000,
        "post": true,
        "tags": [
          "Webpack",
          "React"
        ],
        "title": "实践：基于Webpack5搭建React+TS开发环境",
        "titleEng": "my-react",
        "url": "https://lzxjack.top/post?title=my-react"
      },
      {
        "_id": "617ef50c621f23bc094a8bf221c1d150",
        "_openid": "dbee9976b3c14448a06f2006a4795cf2",
        "classes": "React 学习笔记",
        "content": "使用 React 时，一般来说，使用函数组件`return`一个元素时，该元素是被挂载到其最近的 DOM 父节点下，例如：\n\n```tsx\nreturn (\n  <div>\n    {this.props.children}\n  </div>\n);\n```\n\n挂载了一个新的`div`元素，其子元素被渲染在此`div`中。\n\n但是，我们需要将子元素挂载到其他的任意 DOM 节点下。\n\n例如，最近在实习中遇到一个的问题，要写一个鼠标悬浮时向下弹出选择框的效果。实际效果却是选择框向下弹出，但只显示出了一部分，有一部分不可见。\n\n打开控制台后发现是由于上层组件元素使用了`overflow: hidden`，导致溢出部分被隐藏了。本来想写一个样式覆盖掉`overflow: hidden`，后来发现上层组件**几乎每一层**都使用了`overflow: hidden`。组件设计时就默认这么写的，不可能每一层都去改样式😂。\n\n这时候，我们就需要将子元素挂载到其他的 DOM 节点下。绕过上层使用了`overflow: hidden`的元素，直接挂载到更上层。后来通过 Portals 就解决了这个问题。\n\n## 作用\n\n> Portal 提供了一种将子节点渲染到存在于父组件以外的 DOM 节点的优秀的方案。\n\n以上是<a href=\"https://react.docschina.org/docs/portals.html\" target=\"_blank\">React官网</a>对 Portal 的描述。简单来说，可以将**子元素**渲染到其他的 DOM 节点。\n\n## 用法\n\n```javascript\nReactDOM.createPortal(child, container)\n```\n\n- `child`：ReactNode，可渲染的 React 子元素\n- `container`：Element，DOM 元素\n\n## 示例\n\n如下代码所示，`App`组件是一个大盒子，`App`组件下有一个子组件`PortalTest`：\n\n```tsx\nconst App = () => {\n  return (\n    <div className={s.AppBox} id='app'>\n      <PortalTest />\n    </div>\n  );\n};\n```\n\n子组件`PortalTest`的定义如下：\n\n```tsx\nconst PortalTest = () => {\n  return (\n    <div className={s.A}>\n      <div className={s.B}></div>\n    </div>\n  );\n};\n```\n\n```css\n.A {\n  position: relative;\n  overflow: hidden;\n  width: 100px;\n  height: 100px;\n  background-color: rgb(228, 228, 228);\n}\n\n.B {\n  position: absolute;\n  width: 200px;\n  height: 40px;\n  background-color: rgb(113, 215, 247);\n  top: 50%;\n  transform: translate(0, -50%);\n}\n```\n\n`A`是一个小盒子，`B`是一个小长条，`B`的宽度比`A`长，但由于`A`设置了`overflow: hidden`，`B`超出的部分将隐藏，如图所示：\n\n![](https://img.lzxjack.top:99/202203021456627.png)\n\n真实 DOM 结构如图所示：\n\n![](https://img.lzxjack.top:99/202203021548716.png)\n\n解决方式为，使用`ReactDOM.createPortal()`，将`B`挂载到`App`下，跳过`A`。\n\n```tsx\nconst PortalTest = () => {\n  const [node, setNode] = useState<ReactPortal>();\n\n  useEffect(() => {\n    const test = <div className={s.B}></div>;\n    const app = document.getElementById('app') as Element;\n    setNode(ReactDOM.createPortal(test, app));\n  }, []);\n\n  return <div className={s.A}>{node}</div>;\n};\n```\n\n如上代码所示，使用`ReactDOM.createPortal(test, app)`渲染`B`，挂载到`id`为`app`的 DOM 节点（`App`组件）下。这里使用`useEffect`的原因是，要在`PortalTest`插入到 DOM 树中，才能渲染子元素。\n\n效果如下，由于`B`跳过了`A`，直接挂载到`App`组件的节点下，所以`B`完全展示出来了，不受`A`的`overflow: hidden`的影响。\n\n![](https://img.lzxjack.top:99/202203021509517.png)\n\n真实 DOM 结构如图所示：\n\n![](https://img.lzxjack.top:99/202203021547380.png)\n\n## 冒泡\n\n虽然通过 Portal 可以将子元素挂载到其他的 DOM 节点下，但在其他的任何方面，其行为和普通的 React 子节点行为一致。比如事件冒泡机制，某元素的子元素挂载到其他的 DOM 节点，这个子元素触发的事件，还是会冒泡到该元素上，并不会冒泡至挂载到 DOM 节点。\n\n如下代码所示，有`id`分别为`A`和`B`的两个容器，`A`容器下有`A`盒子，`B`盒子虽然在`A`容器里，但被挂载到`B`容器中：\n\n```tsx\nconst App = () => {\n  const [node, setNode] = useState<ReactPortal>();\n\n  useEffect(() => {\n    const boxB = <div className={s.box}>B</div>;\n    const B = document.getElementById('B') as Element;\n    setNode(ReactDOM.createPortal(boxB, B));\n  }, []);\n\n  const propagationA = () => {\n    console.log('A');\n  };\n  const propagationB = () => {\n    console.log('B');\n  };\n\n  return (\n    <>\n      <div id='A' onClick={propagationA}>\n        <div className={s.box}>A</div>\n        {node}\n      </div>\n      <div id='B' onClick={propagationB}></div>\n    </>\n  );\n};\n```\n\n真实的 DOM 结构如图所示，`B`盒子确实被挂载到了`B`容器中：\n\n![](https://img.lzxjack.top:99/202203021535090.png)\n\n`A`和`B`两容器分别有`click`事件，以显示冒泡效果。结果发现，点击`B`盒子时，控制台也同样打印`'A'`，这说明`B`盒子虽然被挂载到`B`容器下，但是`B`盒子触发的事件，还是会**按照原来的机制**进行冒泡，会冒泡到`A`容器上。\n\n\n\n***\n\n> 以上是本人学习所得之拙见，若有不妥，欢迎指出交流！\n\n> 参考：\n>\n> - <a href=\"https://react.docschina.org/docs/portals.html\" target=\"_blank\">React Portal</a>",
        "date": 1646207856000,
        "post": true,
        "tags": [
          "React"
        ],
        "title": "React Portals：将子节点渲染到其他DOM节点",
        "titleEng": "react-portals",
        "url": "https://lzxjack.top/post?title=react-portals"
      }
    ]
  }
}